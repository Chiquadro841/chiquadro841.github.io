<head>
<link rel="stylesheet" href="style.css">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<h2>Riconoscimento numeri con Reti neurali Convoluzionali<br></h2>

<h3>Panoramica</h3>
<p>
In questo progetto ho realizzato una piccola web app (Javascript - Flask) con lo scopo di mostrare l'utilizzo di CNN (reti neurali convoluzionali) nel
riconoscimento di numeri.<br>
La web app permette in generale di salvare dati sui disegni nel canvas html in un file "records.csv"
creando il proprio dataset su cui addestrare modelli di riconoscimento.<br><br>
Ho formato così un dataset con 3.000 record circa che contiene dati su immagii di cifre da 0-9 e addestrato una rete convoluzionale con accuracy al 90% circa.<br><br>

<a href="https://github.com/chiquadro841/digit_recognition" target="_blank">Link al notebook</a>

<p> Questa è come si presenta l'interfaccia</p>
<img src="img/Screenshot.png" width="600" height="600">

<h3>Come funziona il modello di riconoscimento</h3>
<p>
Per riconoscere le cifre disegnate, il progetto utilizza una <b>Rete Neurale Convoluzionale</b> (CNN), un tipo di modello molto efficace
nel riconoscimento di immagini. L’idea principale è simulare il modo in cui il cervello umano riconosce forme e pattern visivi.
</p>

<h4>Perché una CNN?</h4>
<p>
In un’immagine i pixel non sono semplicemente numeri: hanno posizioni, bordi, curve e strutture ripetute.  
Le CNN sono progettate proprio per estrarre queste caratteristiche automaticamente, senza bisogno di programmarle a mano.
</p>

<h4>Architettura del modello</h4>
<pre><code>model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    MaxPooling2D((2, 2)),
    Dropout(0.25),

    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Dropout(0.25),

    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.5),
    Dense(10, activation='softmax')
])
</code></pre>

<ul>
    <li><b>Conv2D</b>: Applica dei filtri (3×3) all'immagine per individuare bordi, curve e forme</li>
    <li><b>MaxPooling</b>: Riduce la dimensione dell’immagine mantenendo le informazioni importanti. Rende il modello più veloce e più robusto.</li>
    <li><b>Dropout</b>: Disattiva casualmente una parte dei neuroni durante l’addestramento per evitare overfitting</li>
    <li><b>Flatten</b>: Trasforma la matrice dell’immagine in un vettore</li>
    <li><b>Dense(softmax)</b>: Layer finale che decide quale cifra (0-9) è più probabile</li>
</ul>

<h4>Compilazione e addestramento</h4>
<pre><code>model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

model.fit(X_train, y_train, epochs=20, batch_size=32, validation_split=0.2)
</code></pre>

<p>
<ul>
  <li><b>Adam</b>: ottimizzatore che impara automaticamente la velocità migliore di aggiornamento dei pesi</li>
  <li><b>Categorical Crossentropy</b>: misura quanto il modello è distante dall’etichetta corretta</li>
  <li><b>Accuracy</b>: percentuale di cifre classificate correttamente</li>
</ul>
</p>

<p>
Il modello viene allenato per 20 epoche: in ciascuna epoca vede tutte le immagini del dataset e aggiorna i suoi parametri.
Una parte dei dati (validation split) viene tenuta da parte per verificare se la rete sta apprendendo davvero o sta memorizzando.
</p>

<h4>In breve</h4>
<ul>
  <li>Converti il disegno del canvas in un’immagine 28x28</li>
  <li>La CNN estrae le caratteristiche principali</li>
  <li>I layer finali classificano il numero</li>
  <li>La risposta viene mandata alla web app in tempo reale</li>
</ul>

<p>
Questo rende possibile riconoscere cifre disegnate a mano dall’utente in modo veloce e accurato.
</p>
